<!DOCTYPE HTML>
<html>

<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chivo+Mono:wght@500&display=swap" rel="stylesheet">
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" -->
    <!-- integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" -->
    <!-- crossorigin="anonymous"></script> -->
    <script src="{{ url_for('static', filename='socket.io_4.0.1_socket.io.js') }}"></script>
    <script type="text/javascript" charset="utf-8">
        let KEYS = {
            'up': ['KeyK', 'ArrowUp', 'Numpad8'],
            'down': ['KeyJ', 'ArrowDown', 'Numpad2'],
            'left': ['KeyH', 'ArrowLeft', 'Numpad4'],
            'right': ['KeyL', 'ArrowRight', 'Numpad6'],

            'upleft': ['KeyY', 'Numpad7'],
            'upright': ['KeyU', 'Numpad9'],
            'downleft': ['KeyB', 'Numpad1'],
            'downright': ['KeyN', 'Numpad3'],
        };

        let canvas, ctx;
        let gameMap, gamePlayers, gameEnemies, gameItems;
        let myID;
        let players;
        let NUM_ROWS, NUM_COLS;
        let tileSize = 24;
        let halfTile = tileSize / 2;

        let uiX, uiY;
        let sounds;
        let audioPlaying = false;

        // pick a random index for each sound on [1,len]
        let soundMaps = {
            monHit: 2,
            playerHit: 15,
            pickup: 4,
            stairs: 7,
            spawn: 1,
        };

        // utility functions
        // random integer [min, max) -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
        getRandomInt = (min, max) => {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min) + min);
        }

        // c/o https://nluqo.github.io/broughlike-tutorial/stage7.html
        initSounds = () => {
            sounds = {
                bg: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/ambience - small motor and water dripping 2.ogg') }}"),

                monHit1: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/banana hits face 1.ogg') }}"),
                monHit2: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/banana hits face 2.ogg') }}"),

                playerHit1: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 1.ogg') }}"),
                playerHit2: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 2.ogg') }}"),
                playerHit3: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 3.ogg') }}"),
                playerHit4: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 4.ogg') }}"),
                playerHit5: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 5.ogg') }}"),
                playerHit6: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 6.ogg') }}"),
                playerHit7: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 7.ogg') }}"),
                playerHit8: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 8.ogg') }}"),
                playerHit9: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 9.ogg') }}"),
                playerHit10: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 10.ogg') }}"),
                playerHit11: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 11.ogg') }}"),
                playerHit12: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 12.ogg') }}"),
                playerHit13: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 13.ogg') }}"),
                playerHit14: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 14.ogg') }}"),
                playerHit15: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/bat hit 15.ogg') }}"),

                pickup1: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/pick up wood 1.ogg') }}"),
                pickup2: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/pick up wood 2.ogg') }}"),
                pickup3: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/pick up wood 3.ogg') }}"),
                pickup4: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/pick up wood 4.ogg') }}"),

                stairs1: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/step stool opened 1.ogg') }}"),
                stairs2: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/step stool opened 2.ogg') }}"),
                stairs3: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/step stool opened 3.ogg') }}"),
                stairs4: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/step stool opened 4.ogg') }}"),
                stairs5: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/step stool opened 5.ogg') }}"),
                stairs6: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/step stool opened 6.ogg') }}"),
                stairs7: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/step stool opened 7.ogg') }}"),

                spawn1: new Audio("{{ url_for('static', filename='assets/sounds/filmcow/metal dinging underwater 1.ogg') }}"),



                // : new Audio("{{ url_for('static', filename='assets/sounds/filmcow/.wav') }}"),
            }
        }
        playSound = (snd) => {
            if (snd == 'bg') {
                sounds[snd].currentTime = 0;
                sounds[snd].play();
                sounds[snd].loop = true;
            } else {

                let idx = getRandomInt(1, soundMaps[snd] + 1);
                let key = `${snd}${idx}`;
                sounds[key].currentTime = 0;
                sounds[key].play();
            }
        }

        drawMap = () => {
            uiX = canvas.width - 260 + halfTile;
            uiY = tileSize;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#eee";

            ctx.fillText("RL-MMO", uiX, uiY);
            uiY += tileSize;

            if (gamePlayers !== undefined && gameMap !== undefined && gameEnemies !== undefined && gameItems !== undefined) {
                let player = gamePlayers[myID];

                // camera coords for this player
                let startx, endx, starty, endy;
                if (player.pos.c < gameWorld.CAM_HALF_COLS)
                    startx = 0;
                else if (player.pos.c >= gameWorld.NUM_COLS - gameWorld.CAM_HALF_COLS)
                    startx = gameWorld.NUM_COLS - gameWorld.CAM_COLS;
                else
                    startx = player.pos.c - gameWorld.CAM_HALF_COLS;

                if (player.pos.r < gameWorld.CAM_HALF_ROWS)
                    starty = 0;
                else if (player.pos.r >= gameWorld.NUM_ROWS - gameWorld.CAM_HALF_ROWS)
                    starty = gameWorld.NUM_ROWS - gameWorld.CAM_ROWS;
                else
                    starty = player.pos.r - gameWorld.CAM_HALF_ROWS;

                endx = startx + gameWorld.CAM_COLS;
                endy = starty + gameWorld.CAM_ROWS;
                if (endx > gameWorld.NUM_COLS) endx = gameWorld.NUM_COLS;
                if (endy > gameWorld.NUM_ROWS) endy = gameWorld.NUM_ROWS;

                let _x = 0;
                let _y = 0;

                // map
                // for (let r = 0; r < gameMap[0].length; r++) {
                //     for (let c = 0; c < gameMap[0][0].length; c++) {
                for (let r = starty; r < endy; r++) {
                    for (let c = startx; c < endx; c++) {
                        // ctx.fillText(gameMap[player.pos['level']][r][c], c * tileSize, r * tileSize + tileSize);
                        ctx.fillText(gameMap[player.pos['level']][r][c], _x, _y + tileSize);
                        _x += tileSize;
                    }
                    _y += tileSize;
                    _x = 0;
                }

                // items
                ctx.fillStyle = "#00ff00";
                for (const [item_id, item] of Object.entries(gameItems)) {
                    if (item.pos.c >= startx && item.pos.c < endx && item.pos.r >= starty && item.pos.r < endy) {
                        let _x = (item.pos.c - startx) * tileSize;
                        let _y = (item.pos.r - starty) * tileSize + tileSize;

                        // ctx.clearRect(item.pos.c * tileSize, item.pos.r * tileSize, tileSize, tileSize);
                        // ctx.fillText("a", item.pos.c * tileSize, item.pos.r * tileSize + tileSize);
                        ctx.clearRect(_x, _y-tileSize, tileSize, tileSize);
                        ctx.fillText("a", _x, _y);
                    }
                }

                // enemies
                ctx.fillStyle = "#ffff00";
                for (const [enemy_id, enemy] of Object.entries(gameEnemies)) {
                    if (enemy.pos.c >= startx && enemy.pos.c < endx && enemy.pos.r >= starty && enemy.pos.r < endy) {

                        let _x = (enemy.pos.c - startx) * tileSize;
                        let _y = (enemy.pos.r - starty) * tileSize + tileSize;

                        // ctx.clearRect(enemy.pos.c * tileSize, enemy.pos.r * tileSize, tileSize, tileSize);
                        // ctx.fillText("E", enemy.pos.c * tileSize, enemy.pos.r * tileSize + tileSize);
                        ctx.clearRect(_x, _y-tileSize, tileSize, tileSize);
                        ctx.fillText("E", _x, _y);
                    }
                }

                // players
                for (const [player_id, _player] of Object.entries(gamePlayers)) {
                    // TBD: filter entities beforehand and simply don't draw them
                    if (_player.pos.c >= startx && _player.pos.c < endx && _player.pos.r >= starty && _player.pos.r < endy) {

                        let _x = (_player.pos.c - startx) * tileSize;
                        let _y = (_player.pos.r - starty) * tileSize + tileSize;

                        ctx.clearRect(_x, _y-tileSize, tileSize, tileSize);
                        // ctx.clearRect(_player.pos.c * tileSize, _player.pos.r * tileSize, tileSize, tileSize);


                        let a = 255;
                        if (!_player.active)
                            a = 100;
                        ctx.globalAlpha = a / 255;

                        if (player_id == myID) {
                            // draw side information 
                            let apples = 0;
                            if ('apple' in _player.inventory)
                                apples = _player.inventory['apple'];

                            ctx.fillStyle = "#eee";
                            ctx.fillText(`_player ${myID}`, uiX, uiY);
                            uiY += tileSize;
                            ctx.fillText(`HP: ${_player.hp}/${_player.maxHP}`, uiX, uiY);
                            uiY += tileSize;
                            ctx.fillText(`Apples: ${apples}`, uiX, uiY);
                            uiY += tileSize;
                            ctx.fillText(`Level: ${_player.pos.level + 1}`, uiX, uiY);


                            // fill for _player entity
                            ctx.fillStyle = "#ff00ff";
                        } else
                            ctx.fillStyle = "#00ff00";
                        // ctx.fillText("@", _player.pos.c * tileSize, _player.pos.r * tileSize + tileSize);
                        ctx.fillText("@", _x, _y);
                    }
                }
                ctx.globalAlpha = 1.0;
            }

        }
        movePlayer = (socket, pid, c, r) => {
            socket.emit('moveplayer', { playerID: pid, c: c, r: r });
        }
        meditatePlayer = (socket, pid) => {
            socket.emit('meditateplayer', { playerID: pid });
        }
        pickupItem = (socket, pid) => {
            socket.emit('pickupitem', { playerID: pid });
        }
        ascendPlayer = (socket, pid) => {
            socket.emit('ascendplayer', { playerID: pid });
        }
        descendPlayer = (socket, pid) => {
            socket.emit('descendplayer', { playerID: pid });
        }

        // event handling
        document.addEventListener("DOMContentLoaded", (ev) => {
            let _selector = document.querySelector("input[name=allowAudio]")
            _selector.addEventListener('change', function (chk_ev) {
                audioPlaying = !audioPlaying;

                if (audioPlaying)
                    playSound('bg');
                else
                    sounds['bg'].pause();
            });
        });

        window.onload = () => {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext("2d");
            ctx.font = "24px Chivo Mono, Courier";//Courier"
            ctx.fillStyle = "#eee";

            // temp - move to python
            gameMap = undefined;
            gameWorld = undefined;

            gamePlayers = undefined;
            gameEnemies = undefined;
            gameItems = undefined;
            myID = undefined;

            let socket = io();

            initSounds();


            // keyboard handling
            addEventListener("keydown", (ev) => {
                // start on any keypress -- TBD move to a load screen or something later on
                if (sounds['bg'].paused && audioPlaying)
                    playSound('bg');


                switch (ev.key) {
                    // move keys
                    case 'j':
                        movePlayer(socket, myID, 0, 1);
                        break;
                    case 'k':
                        movePlayer(socket, myID, 0, -1);
                        break;
                    case 'h':
                        movePlayer(socket, myID, -1, 0);
                        break;
                    case 'l':
                        movePlayer(socket, myID, 1, 0);
                        break;

                    case 'y':
                        movePlayer(socket, myID, -1, -1);
                        break;
                    case 'u':
                        movePlayer(socket, myID, 1, -1);
                        break;
                    case 'b':
                        movePlayer(socket, myID, -1, 1);
                        break;
                    case 'n':
                        movePlayer(socket, myID, 1, 1);
                        break;

                    // "meditate"
                    case 'm':
                        meditatePlayer(socket, myID);
                        break;

                    // pickup the top item you see
                    // TBD - maybe pick up them all, we'll see how it shakes out
                    case ',':
                        pickupItem(socket, myID);
                        break;

                    // descend
                    case '>':
                        descendPlayer(socket, myID);
                        break;

                    // ascend
                    case '<':
                        ascendPlayer(socket, myID);
                        break;

                    // debug
                    case '.':
                        console.log(gamePlayers[myID]);
                        console.log(gameWorld)
                        console.log(gameMap)

                        break;
                }


                if (gameMap !== undefined)
                    drawMap();
            });

            socket.on('connect', function () {
                socket.emit('my event', { data: 'I\'m connected!' });
            });

            // initial map load
            socket.on('mapload', function (msg) {
                console.log("Parsing received map.")
                myID = msg.playerID;
                gamePlayers = JSON.parse(msg.players);
                gameEnemies = JSON.parse(msg.enemies);
                gameItems = JSON.parse(msg.items);

                gameWorld = JSON.parse(msg.world)
                gameMap = gameWorld.gameMap;

                console.log(gameWorld)
                console.log(gameEnemies)
                console.log(gameMap)
                console.log(gameItems)
                drawMap();
            });

            // tick received
            socket.on('tick', function (msg) {
                gamePlayers = JSON.parse(msg.players);
                gameEnemies = JSON.parse(msg.enemies);
                gameItems = JSON.parse(msg.items);

                // console.log(gamePlayers)
                drawMap();
            });

            // response received from user input (mainly for sound)
            socket.on('serverResponse', function (msg) {
                if (audioPlaying) {
                    switch (msg.resp) {
                        case 'pickupSuccess':
                            playSound('pickup');
                            break;
                        case 'stairUpSuccess':
                        case 'stairDownSuccess':
                            playSound('stairs');
                            break;
                        case 'playerHitMonster':
                            playSound('playerHit');
                            break;
                        case 'monsterHitPlayer':
                            playSound('monsterHit');
                            break;
                        case 'monsterSpawn':
                            console.log("spawning")
                            playSound('spawn');
                            break;
                    }
                }
            });

            // request tick
            let tickInterval = setInterval(function () {
                if (myID !== undefined)
                    socket.emit('tickRequest', { playerID: myID });
            }, 200);
        };



    </script>
    <style>
        * {
            margin: 0px;
            padding: 0px;
            /* background: #000; */
            font-family: 'Chivo Mono', monospace;
            color: #eee;
        }

        /* based on: https://codepen.io/edmundojr/pen/xOYJGw */
        body {
            background: linear-gradient(90deg, #111 21px, transparent 1%) center, linear-gradient(#111 21px, transparent 1%) center, #a799cc;
            background-size: 22px 22px;
        }

        fieldset {
            padding: 10px;
        }

        #game-canvas {
            /* width: 100%; */
            background: #222;

            margin: 0 auto;
            display: block;
            width: 900px;
            /* 640 + 260 */
            height: 480px;
            position: absolute;
            left: 50%;
            top: 50%;

            margin-top: -240px;
            margin-left: -455px;
            /* 900/2 + 10/2 */
            /* margin-left: -320px; */

            border: 5px solid #eee;
            border-radius: 20px;
            padding: 10px;
            /* box-shadow: 0px -15px 45px 0 rgba(220,0,220,0.25), 0 15px 45px 0 rgba(0, 229, 255, 0.25); */

            animation: moveShadow ease-in-out 15s infinite;
        }

        @keyframes moveShadow {
            0% {
                box-shadow: -15px -15px 45px 0 rgba(220, 0, 220, 0.25), 15px 15px 45px 0 rgba(0, 229, 255, 0.25);
            }

            50% {
                box-shadow: 15px -15px 145px 0 rgba(220, 0, 220, 0.25), -15px 15px 145px 0 rgba(0, 229, 255, 0.25);
            }

            100% {
                box-shadow: -15px -15px 45px 0 rgba(220, 0, 220, 0.25), 15px 15px 45px 0 rgba(0, 229, 255, 0.25);
            }
        }


        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
        }
    </style>
</head>

<body>
    <div id="bg"></div>
    <div id="ui">
        <fieldset>
            <legend>UI</legend>
            <div>
                <input type="checkbox" id="allowAudio" name="allowAudio" />
                <label for="allowAudio">Audio?</label>
            </div>
        </fieldset>
    </div>
    <canvas id="game-canvas" width="900" height="480"></canvas>
</body>

</html>